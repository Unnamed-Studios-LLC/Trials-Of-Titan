using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using Utils.NET.IO;
using Utils.NET.Logging;
using Utils.NET.Net.Udp.Packets;

namespace Utils.NET.Net.Udp
{
    public abstract class UdpListener<TCon, TPacket> 
        where TPacket : Packet 
        where TCon : UdpClient<TPacket>
    {
        private class ConnectRequestState
        {
            /// <summary>
            /// Salt received by the client
            /// </summary>
            public ulong clientSalt;

            /// <summary>
            /// Salt generated by the server
            /// </summary>
            public ulong serverSalt;

            /// <summary>
            /// The ip address of the request
            /// </summary>
            public IPEndPoint ipEndpoint;

            public ConnectRequestState(ulong clientSalt, ulong serverSalt, IPEndPoint ipEndpoint)
            {
                this.clientSalt = clientSalt;
                this.serverSalt = serverSalt;
                this.ipEndpoint = ipEndpoint;
            }
        }

        private class SendData
        {
            /// <summary>
            /// The UdpPacket being sent
            /// </summary>
            public readonly UdpPacket packet;

            /// <summary>
            /// The EndPoint to send to
            /// </summary>
            public readonly EndPoint endpoint;

            public SendData(UdpPacket packet, EndPoint endpoint)
            {
                this.packet = packet;
                this.endpoint = endpoint;
            }
        }

        /// <summary>
        /// The port that the listener listens on
        /// </summary>
        private readonly int port;

        /// <summary>
        /// A queue consisting of all available ports
        /// </summary>
        private readonly ConcurrentQueue<int> availablePorts = new ConcurrentQueue<int>();

        /// <summary>
        /// Socket used to receive connection packets
        /// </summary>
        private Socket socket;

        /// <summary>
        /// The EndPoint used to receive packets
        /// </summary>
        private EndPoint receiveEndPoint;

        /// <summary>
        /// Buffer used to store received data
        /// </summary>
        private IO.Buffer buffer;

        /// <summary>
        /// Dictionary containing the states of pending connections
        /// </summary>
        private readonly ConcurrentDictionary<IPEndPoint, ConnectRequestState> requestStates = new ConcurrentDictionary<IPEndPoint, ConnectRequestState>();

        /// <summary>
        /// Dictionary containing all current connections
        /// </summary>
        private readonly ConcurrentDictionary<IPEndPoint, TCon> connections = new ConcurrentDictionary<IPEndPoint, TCon>();

        /// <summary>
        /// Queue of data ready to be sent
        /// </summary>
        private readonly Queue<SendData> sendQueue = new Queue<SendData>();

        /// <summary>
        /// True if the socket is current sending data
        /// </summary>
        private bool sending = false;

        /// <summary>
        /// Int value used to determine if the socket is running
        /// </summary>
        private int running = 0;

        #region Init

        public UdpListener(int port, int maxClients)
        {
            this.port = port;
            InitPorts(maxClients);
            InitSocket();
        }

        /// <summary>
        /// Fills the available ports queue will all ports
        /// </summary>
        /// <param name="maxClients"></param>
        private void InitPorts(int maxClients)
        {
            for (int i = 1; i <= maxClients; i++)
            {
                availablePorts.Enqueue(port + i);
            }
        }

        /// <summary>
        /// Initializes the socket for catching incoming connections
        /// </summary>
        private void InitSocket()
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Bind(new IPEndPoint(IPAddress.Any, port));

            buffer = new IO.Buffer(512);
        }

        #endregion

        #region State Control

        /// <summary>
        /// Starts accepting new clients
        /// </summary>
        public virtual bool Start()
        {
            if (Interlocked.CompareExchange(ref running, 1, 0) != 0) return false; // only allow one call
            BeginRead();
            return true;
        }

        /// <summary>
        /// Stops listening for new clients
        /// </summary>
        public virtual bool Stop()
        {
            if (Interlocked.CompareExchange(ref running, 0, 1) != 1) return false; // only allow one call
            sendQueue.Clear();
            socket.Dispose();
            return true;
        }

        #endregion

        #region Packet Handlers

        /// <summary>
        /// Handles a received UdpPacket
        /// </summary>
        /// <param name="packet">Packet.</param>
        private void HandlePacket(UdpPacket packet, EndPoint endpoint)
        {
            switch (packet.Type)
            {
                case UdpPacketType.Connect:
                    HandleConnect((UdpConnect)packet, endpoint);
                    break;
                case UdpPacketType.Solution:
                    HandleSolution((UdpSolution)packet, endpoint);
                    break;
            }
        }

        /// <summary>
        /// Handles a connect packet
        /// </summary>
        /// <param name="connect">Connect.</param>
        private void HandleConnect(UdpConnect connect, EndPoint endpoint)
        {
            var ipEndpoint = (IPEndPoint)endpoint;
            //var address = ipEndpoint.Address;

            if (availablePorts.Count == 0) // no available ports
            {
                Send(new UdpDisconnect(connect.clientSalt, UdpDisconnectReason.ServerFull), endpoint);
                return;
            }

            if (connections.TryGetValue(ipEndpoint, out var connection))
            {
                Send(new UdpDisconnect(connect.clientSalt, UdpDisconnectReason.ExistingConnection), endpoint);
                return;
            }

            var state = CreateConnectionRequest(connect.clientSalt, ipEndpoint);
            requestStates[ipEndpoint] = state;

            var saltSolution = Udp.CreateSalt(state.clientSalt, state.serverSalt);

            Send(new UdpChallenge(state.clientSalt, state.serverSalt), endpoint);
        }

        /// <summary>
        /// Handles a solution packet
        /// </summary>
        /// <param name="solution">Solution.</param>
        private void HandleSolution(UdpSolution solution, EndPoint endpoint)
        {
            var ipEndpoint = (IPEndPoint)endpoint;
            var address = ipEndpoint.Address;

            if (connections.TryGetValue(ipEndpoint, out var oldcon))
            {
                if (oldcon.salt != solution.salt)
                {
                    Log.Write("New connection failed: already an existing connection");
                    return;
                }

                Send(new UdpConnected(oldcon.salt, (ushort)oldcon.LocalPort), endpoint);
                return;
            }

            if (!requestStates.TryGetValue(ipEndpoint, out var state))
            {
                Log.Write("New connection failed: no request state found");
                return;
            }

            var saltSolution = Udp.CreateSalt(state.clientSalt, state.serverSalt);
            if (solution.salt != saltSolution)
            {
                Log.Write("New connection failed: salt solution invalid");
                return;
            }

            if (!requestStates.TryRemove(ipEndpoint, out state))
            {
                Log.Write("New connection failed: no request state to remove");
                return;
            }

            if (!availablePorts.TryDequeue(out int port))
            {
                Log.Write("New connection failed: failed to assign port");
                return;
            }

            var connection = (TCon)Activator.CreateInstance(typeof(TCon));

            if (!connections.TryAdd(ipEndpoint, connection))
            {
                availablePorts.Enqueue(port); // return port
                connection.Disconnect(UdpDisconnectReason.Custom, true, "Failed to add connection");
                Log.Write("New connection failed: failed to add connection");
                return;
            }

            connection.SetConnectedTo(endpoint, saltSolution, port);
            connection.OnDisconnect += ClientDisconnected;
            HandleConnection(connection);
            connection.StartRead();

            Send(new UdpConnected(saltSolution, (ushort)port), endpoint);
        }

        #endregion

        #region Connecion Methods

        /// <summary>
        /// Handles a new connection
        /// </summary>
        /// <param name="connection"></param>
        protected abstract void HandleConnection(TCon connection);

        private ConnectRequestState CreateConnectionRequest(ulong clientSalt, IPEndPoint ipEndpoint)
        {
            ulong serverSalt = Udp.GenerateLocalSalt();
            return new ConnectRequestState(clientSalt, serverSalt, ipEndpoint);
        }

        /// <summary>
        /// Method called when a given client has been disconnected
        /// </summary>
        /// <param name="connection"></param>
        private void ClientDisconnected(UdpClient<TPacket> client)
        {
            if (!connections.TryRemove(client.RemoteEndPoint, out var connection)) return;
            HandleDisconnection(connection);
            availablePorts.Enqueue(connection.LocalPort);
        }

        /// <summary>
        /// Handles a connection disconnecting
        /// </summary>
        /// <param name="connection"></param>
        protected abstract void HandleDisconnection(TCon connection);

        #endregion

        #region Reading

        /// <summary>
        /// Starts receiving data
        /// </summary>
        private void BeginRead()
        {
            receiveEndPoint = new IPEndPoint(IPAddress.Any, 0);
            socket.BeginReceiveFrom(buffer.data, 0, buffer.maxSize, SocketFlags.None, ref receiveEndPoint, OnRead, null);
        }

        /// <summary>
        /// Read callback for the receiving socket
        /// </summary>
        /// <param name="ar">Ar.</param>
        private void OnRead(IAsyncResult ar)
        {
            EndPoint fromEndpoint = new IPEndPoint(IPAddress.Any, 0);
            int length = 0;
            try
            {
                length = socket.EndReceiveFrom(ar, ref fromEndpoint);
            }
            catch (ObjectDisposedException)
            {
                return;
            }

            byte[] data = new byte[length];
            System.Buffer.BlockCopy(buffer.data, 0, data, 0, length);
            BeginRead(); // start reading for more packets

            BitReader r = new BitReader(data, length);
            bool isUdp = r.ReadBool();
            if (!isUdp) return; // only accept udp packets
            byte id = r.ReadUInt8();
            var packet = Udp.CreateUdpPacket(id);
            if (packet == null) return; // failed to create a packet from the given id value
            packet.ReadPacket(r);
            HandlePacket(packet, fromEndpoint);
        }

        #endregion

        #region Sending

        /// <summary>
        /// Sends a packet to a given endpoint
        /// </summary>
        /// <param name="packet">Packet.</param>
        /// <param name="endpoint">Endpoint.</param>
        private void Send(UdpPacket packet, EndPoint endpoint)
        {
            if (running == 0) return; // return if not running
            var data = new SendData(packet, endpoint);
            lock (sendQueue)
            {
                if (sending)
                {
                    sendQueue.Enqueue(data);
                    return;
                }
                sending = true;
            }

            Send(data);
        }

        /// <summary>
        /// Sends the data
        /// </summary>
        /// <param name="data">Data.</param>
        private void Send(SendData data)
        {
            var sendBuffer = PackagePacket(data);
            socket.BeginSendTo(sendBuffer.data, 0, sendBuffer.size, SocketFlags.None, data.endpoint, OnSend, null);
        }

        /// <summary>
        /// Send callback
        /// </summary>
        /// <param name="ar">Ar.</param>
        private void OnSend(IAsyncResult ar)
        {
            int sentLength = socket.EndSendTo(ar);

            SendData nextPacket;
            lock (sendQueue)
            {
                if (sendQueue.Count == 0)
                {
                    sending = false;
                    return;
                }
                nextPacket = sendQueue.Dequeue();
            }

            Send(nextPacket);
        }

        /// <summary>
        /// Packages a packet into a buffer to send
        /// </summary>
        /// <returns>The packet.</returns>
        /// <param name="data">The packet data to send</param>
        private IO.Buffer PackagePacket(SendData data)
        {
            var w = new BitWriter();
            w.Write(true);
            w.Write(data.packet.Id);
            data.packet.WritePacket(w);
            return w.GetData();
        }

        #endregion
    }
}
